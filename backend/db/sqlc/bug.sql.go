// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: bug.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const closeBug = `-- name: CloseBug :one
UPDATE bug
SET completed = TRUE,
    closedBy = $1,
    remarks = $2,
    closedAt = NOW()
WHERE id = $3
RETURNING id, name, description, status, priority, assignedto, assignedby, completed, createdat, updatedat, closedby, remarks, closedat
`

type CloseBugParams struct {
	Closedby pgtype.UUID `json:"closedby"`
	Remarks  pgtype.Text `json:"remarks"`
	ID       uuid.UUID   `json:"id"`
}

func (q *Queries) CloseBug(ctx context.Context, arg CloseBugParams) (Bug, error) {
	row := q.db.QueryRow(ctx, closeBug, arg.Closedby, arg.Remarks, arg.ID)
	var i Bug
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.Assignedto,
		&i.Assignedby,
		&i.Completed,
		&i.Createdat,
		&i.Updatedat,
		&i.Closedby,
		&i.Remarks,
		&i.Closedat,
	)
	return i, err
}

const createBug = `-- name: CreateBug :one
INSERT INTO bug(
        id,
        name,
        description,
        status,
        priority,
        assignedTo,
        assignedBy
    )
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, name, description, status, priority, assignedto, assignedby, completed, createdat, updatedat, closedby, remarks, closedat
`

type CreateBugParams struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Status      Bugstatus   `json:"status"`
	Priority    Bugpriority `json:"priority"`
	Assignedto  uuid.UUID   `json:"assignedto"`
	Assignedby  uuid.UUID   `json:"assignedby"`
}

func (q *Queries) CreateBug(ctx context.Context, arg CreateBugParams) (Bug, error) {
	row := q.db.QueryRow(ctx, createBug,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.Priority,
		arg.Assignedto,
		arg.Assignedby,
	)
	var i Bug
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.Assignedto,
		&i.Assignedby,
		&i.Completed,
		&i.Createdat,
		&i.Updatedat,
		&i.Closedby,
		&i.Remarks,
		&i.Closedat,
	)
	return i, err
}

const deleteBug = `-- name: DeleteBug :one
DELETE FROM bug
WHERE id = $1
RETURNING id, name, description, status, priority, assignedto, assignedby, completed, createdat, updatedat, closedby, remarks, closedat
`

func (q *Queries) DeleteBug(ctx context.Context, id uuid.UUID) (Bug, error) {
	row := q.db.QueryRow(ctx, deleteBug, id)
	var i Bug
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.Assignedto,
		&i.Assignedby,
		&i.Completed,
		&i.Createdat,
		&i.Updatedat,
		&i.Closedby,
		&i.Remarks,
		&i.Closedat,
	)
	return i, err
}

const getActiveBugsByProfile = `-- name: GetActiveBugsByProfile :many
SELECT b.id, b.name, b.description, b.status, b.priority, b.assignedto, b.assignedby, b.completed, b.createdat, b.updatedat, b.closedby, b.remarks, b.closedat
FROM bug b
    INNER JOIN team t ON b.assignedTo = t.id
    INNER JOIN teamMember tm ON t.id = tm.team
WHERE tm.profile = $1
    AND completed = FALSE
ORDER BY b.priority DESC,
    b.status DESC
`

func (q *Queries) GetActiveBugsByProfile(ctx context.Context, profile uuid.UUID) ([]Bug, error) {
	rows, err := q.db.Query(ctx, getActiveBugsByProfile, profile)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bug{}
	for rows.Next() {
		var i Bug
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.Assignedto,
			&i.Assignedby,
			&i.Completed,
			&i.Createdat,
			&i.Updatedat,
			&i.Closedby,
			&i.Remarks,
			&i.Closedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBug = `-- name: GetBug :one
SELECT id, name, description, status, priority, assignedto, assignedby, completed, createdat, updatedat, closedby, remarks, closedat
FROM bug b
WHERE id = $1
`

func (q *Queries) GetBug(ctx context.Context, id uuid.UUID) (Bug, error) {
	row := q.db.QueryRow(ctx, getBug, id)
	var i Bug
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.Assignedto,
		&i.Assignedby,
		&i.Completed,
		&i.Createdat,
		&i.Updatedat,
		&i.Closedby,
		&i.Remarks,
		&i.Closedat,
	)
	return i, err
}

const getBugsByAsigneeTeam = `-- name: GetBugsByAsigneeTeam :many
SELECT b.id, b.name, b.description, b.status, b.priority, b.assignedto, b.assignedby, b.completed, b.createdat, b.updatedat, b.closedby, b.remarks, b.closedat
FROM bug b
    INNER JOIN teamMember tm ON b.assignedBy = tm.profile
WHERE tm.team = $1
ORDER BY b.priority DESC,
    b.status DESC,
    b.completed DESC
`

func (q *Queries) GetBugsByAsigneeTeam(ctx context.Context, team uuid.UUID) ([]Bug, error) {
	rows, err := q.db.Query(ctx, getBugsByAsigneeTeam, team)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bug{}
	for rows.Next() {
		var i Bug
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.Assignedto,
			&i.Assignedby,
			&i.Completed,
			&i.Createdat,
			&i.Updatedat,
			&i.Closedby,
			&i.Remarks,
			&i.Closedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBugsByAssignedTeam = `-- name: GetBugsByAssignedTeam :many
SELECT id, name, description, status, priority, assignedto, assignedby, completed, createdat, updatedat, closedby, remarks, closedat
FROM bug
WHERE assignedTo = $1
ORDER BY priority DESC,
    status DESC,
    completed DESC
`

func (q *Queries) GetBugsByAssignedTeam(ctx context.Context, assignedto uuid.UUID) ([]Bug, error) {
	rows, err := q.db.Query(ctx, getBugsByAssignedTeam, assignedto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bug{}
	for rows.Next() {
		var i Bug
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.Assignedto,
			&i.Assignedby,
			&i.Completed,
			&i.Createdat,
			&i.Updatedat,
			&i.Closedby,
			&i.Remarks,
			&i.Closedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBug = `-- name: UpdateBug :one
UPDATE bug
SET name = $1,
    description = $2,
    status = $3,
    priority = $4,
    assignedTo = $5,
    updatedAt = NOW()
WHERE id = $6
RETURNING id, name, description, status, priority, assignedto, assignedby, completed, createdat, updatedat, closedby, remarks, closedat
`

type UpdateBugParams struct {
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Status      Bugstatus   `json:"status"`
	Priority    Bugpriority `json:"priority"`
	Assignedto  uuid.UUID   `json:"assignedto"`
	ID          uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateBug(ctx context.Context, arg UpdateBugParams) (Bug, error) {
	row := q.db.QueryRow(ctx, updateBug,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.Priority,
		arg.Assignedto,
		arg.ID,
	)
	var i Bug
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.Assignedto,
		&i.Assignedby,
		&i.Completed,
		&i.Createdat,
		&i.Updatedat,
		&i.Closedby,
		&i.Remarks,
		&i.Closedat,
	)
	return i, err
}
